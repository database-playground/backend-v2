package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.79

import (
	"context"
	"errors"

	"entgo.io/contrib/entgql"
	"github.com/database-playground/backend-v2/ent"
	"github.com/database-playground/backend-v2/ent/question"
	entSubmission "github.com/database-playground/backend-v2/ent/submission"
	"github.com/database-playground/backend-v2/graph/defs"
	"github.com/database-playground/backend-v2/graph/model"
	"github.com/database-playground/backend-v2/internal/auth"
	"github.com/database-playground/backend-v2/internal/scope"
	"github.com/database-playground/backend-v2/internal/submission"
	"github.com/database-playground/backend-v2/models"
)

// CreateQuestion is the resolver for the createQuestion field.
func (r *mutationResolver) CreateQuestion(ctx context.Context, input ent.CreateQuestionInput) (*ent.Question, error) {
	entClient := r.EntClient(ctx)

	question, err := entClient.Question.Create().SetInput(input).Save(ctx)
	if err != nil {
		return nil, err
	}

	return question, nil
}

// UpdateQuestion is the resolver for the updateQuestion field.
func (r *mutationResolver) UpdateQuestion(ctx context.Context, id int, input ent.UpdateQuestionInput) (*ent.Question, error) {
	entClient := r.EntClient(ctx)

	question, err := entClient.Question.UpdateOneID(id).SetInput(input).Save(ctx)
	if err != nil {
		return nil, err
	}

	return question, nil
}

// DeleteQuestion is the resolver for the deleteQuestion field.
func (r *mutationResolver) DeleteQuestion(ctx context.Context, id int) (bool, error) {
	entClient := r.EntClient(ctx)

	err := entClient.Question.DeleteOneID(id).Exec(ctx)
	if err != nil {
		return false, err
	}

	return true, nil
}

// CreateDatabase is the resolver for the createDatabase field.
func (r *mutationResolver) CreateDatabase(ctx context.Context, input ent.CreateDatabaseInput) (*ent.Database, error) {
	entClient := r.EntClient(ctx)

	database, err := entClient.Database.Create().SetInput(input).Save(ctx)
	if err != nil {
		return nil, err
	}

	return database, nil
}

// UpdateDatabase is the resolver for the updateDatabase field.
func (r *mutationResolver) UpdateDatabase(ctx context.Context, id int, input ent.UpdateDatabaseInput) (*ent.Database, error) {
	entClient := r.EntClient(ctx)

	database, err := entClient.Database.UpdateOneID(id).SetInput(input).Save(ctx)
	if err != nil {
		return nil, err
	}

	return database, nil
}

// DeleteDatabase is the resolver for the deleteDatabase field.
func (r *mutationResolver) DeleteDatabase(ctx context.Context, id int) (bool, error) {
	entClient := r.EntClient(ctx)

	err := entClient.Database.DeleteOneID(id).Exec(ctx)
	if err != nil {
		return false, err
	}

	return true, nil
}

// SubmitAnswer is the resolver for the submitAnswer field.
func (r *mutationResolver) SubmitAnswer(ctx context.Context, id int, answer string) (*model.SubmissionResult, error) {
	user, ok := auth.GetUser(ctx)
	if !ok {
		return nil, defs.ErrUnauthorized
	}

	submissionResult, err := r.submissionService.SubmitAnswer(ctx, submission.SubmitAnswerInput{
		SubmitterID: user.UserID,
		QuestionID:  id,
		Answer:      answer,
	})
	if err != nil {
		if errors.Is(err, submission.ErrQuestionNotFound) {
			return nil, defs.ErrNotFound
		}

		return nil, err
	}

	return &model.SubmissionResult{
		Result: submissionResult.QueryResult,
		Error:  submissionResult.Error,
	}, nil
}

// Question is the resolver for the question field.
func (r *queryResolver) Question(ctx context.Context, id int) (*ent.Question, error) {
	entClient := r.EntClient(ctx)

	question, err := entClient.Question.Get(ctx, id)
	if err != nil {
		return nil, err
	}

	return question, nil
}

// Database is the resolver for the database field.
func (r *queryResolver) Database(ctx context.Context, id int) (*ent.Database, error) {
	entClient := r.EntClient(ctx)

	database, err := entClient.Database.Get(ctx, id)
	if err != nil {
		return nil, err
	}

	return database, nil
}

// Submission is the resolver for the submission field.
func (r *queryResolver) Submission(ctx context.Context, id int) (*ent.Submission, error) {
	entClient := r.EntClient(ctx)

	tokenInfo, ok := auth.GetUser(ctx)
	if !ok {
		return nil, defs.ErrUnauthorized
	}

	submission, err := entClient.Submission.Get(ctx, id)
	if ent.IsNotFound(err) {
		return nil, defs.ErrNotFound
	}
	if err != nil {
		return nil, err
	}

	// Check if the user has the "submission:read" scope
	// If no, check if the submission is owned by the user
	if !scope.ShouldAllow("submission:read", tokenInfo.Scopes) {
		user, err := submission.User(ctx)
		if err != nil {
			return nil, err
		}
		if user.ID != tokenInfo.UserID {
			return nil, defs.ErrForbidden
		}

		return submission, nil
	}

	return submission, nil
}

// ReferenceAnswerResult is the resolver for the referenceAnswerResult field.
func (r *questionResolver) ReferenceAnswerResult(ctx context.Context, obj *ent.Question) (*models.SQLExecutionResult, error) {
	database, err := obj.QueryDatabase().Only(ctx)
	if err != nil {
		return nil, err
	}

	response, err := r.sqlrunner.Query(ctx, database.Schema, obj.ReferenceAnswer)
	if err != nil {
		return nil, err
	}

	return &models.SQLExecutionResult{
		Columns: response.Columns,
		Rows:    response.Rows,
	}, nil
}

// SubmissionsOfQuestion is the resolver for the submissionsOfQuestion field.
func (r *userResolver) SubmissionsOfQuestion(ctx context.Context, obj *ent.User, questionID int, after *entgql.Cursor[int], first *int, before *entgql.Cursor[int], last *int, where *model.SubmissionsOfQuestionWhereInput, orderBy *ent.SubmissionOrder) (*ent.SubmissionConnection, error) {
	query := obj.QuerySubmissions()
	query.Where(entSubmission.HasQuestionWith(question.ID(questionID)))

	if where != nil {
		if where.Status != nil {
			query.Where(entSubmission.StatusEQ(*where.Status))
		}
	}

	return query.Paginate(ctx, after, first, before, last, ent.WithSubmissionOrder(orderBy))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
